{
  "$schema" : "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
  "version" : "2.1.0",
  "runs" : [ {
    "tool" : {
      "driver" : {
        "name" : "Fortify on Demand",
        "version" : "SCA version unknown; Rulepack version unknown",
        "rules" : [ {
          "id" : "146172283",
          "shortDescription" : {
            "text" : "Cookie Security: CSRF Cookie not Sent Over SSL"
          },
          "fullDescription" : {
            "text" : "The program does not explicitly set the CSRF_COOKIE_SECURE property to True or sets it to False in settings.py on line 16. The program does not explicitly set the CSRF_COOKIE_SECURE property to True or set it to False."
          },
          "help" : {
            "text" : "Modern web browsers support a Secure flag for each cookie. If the flag is set, the browser will only send the cookie over HTTPS. Sending cookies over an unencrypted channel can expose them to network sniffing attacks, so the secure flag helps keep a cookie's value confidential. This is especially important if the cookie contains private data, session identifiers, or carries a CSRF token.\n\nIn this case, the program fails to set the CSRF_COOKIE_SECURE property to True in settings.py on line 16.\n\n\nExample 1: The following configuration entry does not explicitly set the Secure bit for CSRF cookies.\n\n...\nMIDDLEWARE_CLASSES = (\n'django.middleware.csrf.CsrfViewMiddleware',\n'django.contrib.sessions.middleware.SessionMiddleware',\n'django.middleware.common.CommonMiddleware',\n'django.contrib.auth.middleware.AuthenticationMiddleware',\n'django.contrib.messages.middleware.MessageMiddleware',\n'csp.middleware.CSPMiddleware',\n'django.middleware.security.SecurityMiddleware',\n...\n)\n...\n\n\nIf an application uses both HTTPS and HTTP, but does not set the Secure flag, cookies sent during an HTTPS request will also be sent during subsequent HTTP requests. Attackers may then compromise the cookie by sniffing the unencrypted network traffic, which is particularly easy over wireless networks.\n\nSet the Secure flag on all cookies in order to instruct browsers not to send these cookies over HTTP.\n\nExample 2: The following code corrects the mistake in Example 1 by explicitly setting the CSRF_COOKIE_SECURE property to True.\n\n\n...\nMIDDLEWARE_CLASSES = (\n'django.middleware.csrf.CsrfViewMiddleware',\n'django.contrib.sessions.middleware.SessionMiddleware',\n'django.middleware.common.CommonMiddleware',\n'django.contrib.auth.middleware.AuthenticationMiddleware',\n'django.contrib.messages.middleware.MessageMiddleware',\n'csp.middleware.CSPMiddleware',\n'django.middleware.security.SecurityMiddleware',\n...\n)\n...\nCSRF_COOKIE_SECURE = True\n...\n\n\nFor more information, see https://ams.fortify.com//redirect/Issues/22f04444-c09c-4cd2-8fc7-80fed9c14cda"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "146172290",
          "shortDescription" : {
            "text" : "Cookie Security: Session Cookie not Sent Over SSL"
          },
          "fullDescription" : {
            "text" : "The program does not explicitly set the SESSION_COOKIE_SECURE property to True or set it to False in settings.py on line 16. The program does not explicitly set the SESSION_COOKIE_SECURE property to True or set it to False."
          },
          "help" : {
            "text" : "Modern web browsers support a Secure flag for each cookie. If the flag is set, the browser will only send the cookie over HTTPS. Sending cookies over an unencrypted channel can expose them to network sniffing attacks, so the secure flag helps keep a cookie's value confidential. This is especially important if the cookie contains private data, session identifiers, or carries a CSRF token.\n\nIn this case, the program fails to set the SESSION_COOKIE_SECURE property to True in settings.py on line 16.\n\n\nExample 1: The following configuration entry does not explicitly set the Secure bit for session cookies.\n\n...\nMIDDLEWARE_CLASSES = (\n'django.middleware.csrf.CsrfViewMiddleware',\n'django.contrib.sessions.middleware.SessionMiddleware',\n'django.middleware.common.CommonMiddleware',\n'django.contrib.auth.middleware.AuthenticationMiddleware',\n'django.contrib.messages.middleware.MessageMiddleware',\n'csp.middleware.CSPMiddleware',\n'django.middleware.security.SecurityMiddleware',\n...\n)\n...\n\n\nIf an application uses both HTTPS and HTTP, but does not set the Secure flag, cookies sent during an HTTPS request will also be sent during subsequent HTTP requests. Attackers may then compromise the cookie by sniffing the unencrypted network traffic, which is particularly easy over wireless networks.\n\nSet the Secure flag on all cookies in order to instruct browsers not to send these cookies over HTTPS.\n\nExample 2: The following code corrects the mistake in Example 1 by explicitly setting the SESSION_COOKIE_SECURE property to True.\n\n\n...\nMIDDLEWARE_CLASSES = (\n'django.middleware.csrf.CsrfViewMiddleware',\n'django.contrib.sessions.middleware.SessionMiddleware',\n'django.middleware.common.CommonMiddleware',\n'django.contrib.auth.middleware.AuthenticationMiddleware',\n'django.contrib.messages.middleware.MessageMiddleware',\n'csp.middleware.CSPMiddleware',\n'django.middleware.security.SecurityMiddleware',\n...\n)\n...\nSESSION_COOKIE_SECURE = True\n...\n\n\nFor more information, see https://ams.fortify.com//redirect/Issues/80eeef6e-5c97-40f6-b632-1708f5f2ab38"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "146172282",
          "shortDescription" : {
            "text" : "Django Bad Practices: Cookie Stored Sessions"
          },
          "fullDescription" : {
            "text" : "Cookie-based sessions are not invalidated when a user logs out. If an attacker were to find, steal, or intercept a user's cookie they could impersonate the user even if that user had logged out."
          },
          "help" : {
            "text" : "Storing session data in Cookies presents several problems:\n\n1. Cookie-based sessions are not invalidated when a user logs out. If an attacker were to find, steal, or intercept a user's cookie they could impersonate the user even if that user had logged out.\n\n2. Session cookies are signed to avoid tampering and guarantee the authenticity of the data, but it will not prevent replay attacks.\n\n3. The session data will be stored using Django's tools for cryptographic signing and the SECRET_KEY setting. If the SECRET_KEY is leaked, an attacker cannot only falsify session data, but if application uses Pickle to serialize session data into cookies, an attacker will be able to craft malicious pickled data that will execute arbitrary code upon deserialization.\n\n4. The session data is signed but not encrypted. This means that attackers will be able to read the session data but not modify it.\n\n5. The cookie size and serialization process can pose a performace problem depending on site load.\n\nIf possible, do not use cookie-based sessions. Store session data in the server and always invalidate sessions when users log out.\n\nDjango offers the following alternatives:\n1. Database-backed sessions (Default option)\n2. Memcached-based sessions\n3. File-based sessions\n\nFor more information, see https://ams.fortify.com//redirect/Issues/4e2f65e9-cb89-43fc-ba74-ea268c9ea9c1"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "146172279",
          "shortDescription" : {
            "text" : "Django Bad Practices: Pickle Serialized Sessions"
          },
          "fullDescription" : {
            "text" : "Pickle-serialized sessions can lead to remote code execution if attackers can control session data."
          },
          "help" : {
            "text" : "If cookie-based sessions are used and SECRET_KEY is leaked, an attacker will be able to store arbitrary data in the session cookie which will be deserialized in the server leading to arbitrary code execution.\n\nIf cookie-based sessions are used, take extra care to make sure that the secret key is always kept completely secret, for any system which might be remotely accessible.\n\nExample 1: The following view method allows an attacker to steal the SECRET_KEY if it is hardcoded in settings.py configuration file:\n\n\n...\ndef some_view_method(request):\nurl = request.GET['url']\nif \"http://\" in url:\ncontent = urllib.urlopen(url)\nreturn HttpResponse(content)\n...\n\n\nExample 1 method checks that the url parameter is a valid URL by checking that \"http://\" is present in the URL. A malicious attacker may send the following URL to leak the settings.py configuration file that may contain the SECRET_KEY:\n\n\nfile://proc/self/cwd/app/settings.py#http://\n\n\nNote: \"/proc/self/cwd\" in UNIX systems points to the process working directory. This allow attackers to reference files without knowing the exact location.\n\nUse JSON rather than pickle to serialize session data. Django 1.5.3 introduced a new setting, SESSION_SERIALIZER, to customize the session serialization format. This setting defaults to django.contrib.sessions.serializers.PickleSerializer in Django 1.5.x, but, for security hardening, defaults to django.contrib.sessions.serializers.JSONSerializer since Django 1.6. It is highly recommended to use JSON serialization when using cookie-based sessions, since in case that SECRET_KEY is compromised, JSON deserialization won't lead to a remote code execution.\n\nFor more information, see https://ams.fortify.com//redirect/Issues/2f033aa0-14e5-4470-b9ba-cfae0c4349e3"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "146172285",
          "shortDescription" : {
            "text" : "Insecure Transport"
          },
          "fullDescription" : {
            "text" : "The application is not configured to send HTTP redirects over SSL/TLS."
          },
          "help" : {
            "text" : "All communication over HTTP, FTP, or gopher is unauthenticated and unencrypted. It is therefore subject to compromise.\n\nDjango does not serve HTTP redirects over SSL by default, so data in these redirected connections can be compromised as they are delivered over an unencrypted and unauthenticated channel.\n\nExample 1: The following code uses the SecurityMiddleware but does not explicitly set SECURE_SSL_REDIRECT to True.\n\n\n...\nMIDDLEWARE_CLASSES = (\n'django.middleware.csrf.CsrfViewMiddleware',\n'django.contrib.sessions.middleware.SessionMiddleware',\n'django.middleware.common.CommonMiddleware',\n'django.contrib.auth.middleware.AuthenticationMiddleware',\n'django.contrib.messages.middleware.MessageMiddleware',\n'csp.middleware.CSPMiddleware',\n'django.middleware.security.SecurityMiddleware',\n...\n)\n...\n\n\nUse secure protocols such as HTTPS to exchange data with the server whenever possible.\n\nSet the SECURE_SSL_REDIRECT setting to True if all non-SSL requests should be permanently redirected to SSL. This configuration property is available in Django version 1.8+. If using an earlier version, the django-secure middleware plugin can be used instead.\n\nExample 1: The following code uses the SecurityMiddleware and explicitly sets SECURE_SSL_REDIRECT to True.\n\n\n...\nMIDDLEWARE_CLASSES = (\n'django.middleware.csrf.CsrfViewMiddleware',\n'django.contrib.sessions.middleware.SessionMiddleware',\n'django.middleware.common.CommonMiddleware',\n'django.contrib.auth.middleware.AuthenticationMiddleware',\n'django.contrib.messages.middleware.MessageMiddleware',\n'csp.middleware.CSPMiddleware',\n'django.middleware.security.SecurityMiddleware',\n...\n)\n...\nSECURE_SSL_REDIRECT = True\n...\n\n\nFor more information, see https://ams.fortify.com//redirect/Issues/f3334f0e-464b-4ced-9f43-8ca2ebc2ef7c"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "146172278",
          "shortDescription" : {
            "text" : "Insecure Transport: HSTS not Set"
          },
          "fullDescription" : {
            "text" : "The application does not set HTTP Strict Transport Security (HSTS) headers, allowing attackers to replace SSL/TLS connections with plain HTTP ones and steal sensitive information by performing HTTPS stripping attacks."
          },
          "help" : {
            "text" : "An HTTPS stripping attack is a type of man-in-the-middle attack where the attacker watches all the HTTP traffic for location headers and links referencing HTTPS and replaces them with HTTP versions. The attacker keeps a list of all HTTP substitutions made so that they can make the HTTPS request back to the server. All stripped HTTP connections are proxied out to the server over HTTPS. All traffic between the victim and the attacker is sent over HTTP, revealing usernames, passwords, and other private information, but the server is still receiving the expected HTTPS traffic from the attacker so nothing seems wrong.\n\nHTTP Strict Transport Security (HSTS) is a security header that instructs the browser to always connect to the site returning the HSTS headers over SSL/TLS during a period specified in the header itself. Any connection to the server over HTTP will be automatically replaced with an HTTPS one, even if the user types http:// in the browser URL bar.\n\nDjango 1.8+ and older Django versions using django-secure plugin can enable HSTS headers using the following settings:\n\n\n...\nSECURE_HSTS_SECONDS = 31536000\nSECURE_HSTS_INCLUDE_SUBDOMAINS = True\n...\n\n\nFor more information, see https://ams.fortify.com//redirect/Issues/77b5d982-19d5-47da-854a-9a95cdd5806d"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "146172281",
          "shortDescription" : {
            "text" : "Key Management: Hardcoded Encryption Key"
          },
          "fullDescription" : {
            "text" : "Hardcoded encryption keys could compromise system security in a way that cannot be easily remedied."
          },
          "help" : {
            "text" : "It is never a good idea to hardcode an encryption key. Not only does hardcoding an encryption key allow all of the project's developers to view the encryption key, it also makes fixing the problem extremely difficult. After the code is in production, a software patch is required to change the encryption key. If the account protected by the encryption key is compromised, the owners of the system must choose between security and availability.\n\nIn this case, the encryption key was used to access a resource at  in settings.py on line 24.\n\n\nExample: The following code uses a hardcoded encryption key to encrypt information:\n\n...\nfrom Crypto.Ciphers import AES\nencryption_key = b'_hardcoded__key_'\ncipher = AES.new(encryption_key, AES.MODE_CFB, iv)\nmsg = iv + cipher.encrypt(b'Attack at dawn')\n...\n\n\nThis code will run successfully, but anyone who has access to it will have access to the encryption key. After the program ships, there is likely no way to change the hardcoded encryption key _hardcoded__key_ unless the program is patched. A devious employee with access to this information can use it to compromise data encrypted by the system.\n\nEncryption keys should never be hardcoded and should generally be obfuscated and managed in an external source. Storing encryption keys in plain text anywhere on the system allows anyone with sufficient permissions to read and potentially misuse the encryption key.\n\nFor more information, see https://ams.fortify.com//redirect/Issues/c04e7f4b-3d68-42dc-8b0b-5b7eb70dbc2a"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "146172284",
          "shortDescription" : {
            "text" : "Open Redirect"
          },
          "fullDescription" : {
            "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 368. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
          },
          "help" : {
            "text" : "Redirects allow web applications to direct users to different pages within the same application or to external sites. Applications utilize redirects to aid in site navigation and, in some cases, to track how users exit the site. Open redirect vulnerabilities occur when a web application redirects clients to any arbitrary URL that can be controlled by an attacker.\n\nAttackers might utilize open redirects to trick users into visiting a URL to a trusted site, but then redirecting them to a malicious site. By encoding the URL, an attacker can make it difficult for end-users to notice the malicious destination of the redirect, even when it is passed as a URL parameter to the trusted site. Open redirects are often abused as part of phishing scams to harvest sensitive end-user data.\n\n\nIn this case, the URL the client will be redirected to is accepted at project_edit() in views.py on line 350.\n\n\nThe data is sent at redirect() in views.py on line 368.\n\n\nExample 1: The following Python code instructs the user's browser to open a URL parsed from the dest request parameter when a user clicks the link.\n\n\n...\nstrDest = request.field(\"dest\")\nredirect(strDest)\n...\n\n\nIf a victim received an email instructing them to follow a link to \"http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com\", the user would likely click on the link believing they would be transferred to the trusted site. However, when the victim clicks the link, the code in Example 1 will redirect the browser to \"http://www.wilyhacker.com\".\n\nMany users have been educated to always inspect URLs they receive in emails to make sure the link specifies a trusted site they know. However, if the attacker Hex encoded the destination url as follows:\n\"http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D\"\n\nthen even a savvy end-user may be fooled into following the link.\n\nUnvalidated user input should not be allowed to control the destination URL in a redirect. Instead, use a level of indirection: create a list of legitimate URLs that users are allowed to specify and only allow users to select from the list. With this approach, input provided by users is never used directly to specify a URL for redirects.\n\nIn some situations this approach is impractical because the set of legitimate URLs is too large or too hard to keep track of. In such cases, use a similar approach to restrict the domains that users can be redirected to, which can at least prevent attackers from sending users to malicious external sites.\n\nFor more information, see https://ams.fortify.com//redirect/Issues/9ceaa05f-47a8-469b-a06c-6d27339ae79d"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "146172286",
          "shortDescription" : {
            "text" : "Open Redirect"
          },
          "fullDescription" : {
            "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 319. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
          },
          "help" : {
            "text" : "Redirects allow web applications to direct users to different pages within the same application or to external sites. Applications utilize redirects to aid in site navigation and, in some cases, to track how users exit the site. Open redirect vulnerabilities occur when a web application redirects clients to any arbitrary URL that can be controlled by an attacker.\n\nAttackers might utilize open redirects to trick users into visiting a URL to a trusted site, but then redirecting them to a malicious site. By encoding the URL, an attacker can make it difficult for end-users to notice the malicious destination of the redirect, even when it is passed as a URL parameter to the trusted site. Open redirects are often abused as part of phishing scams to harvest sensitive end-user data.\n\n\nIn this case, the URL the client will be redirected to is accepted at task_complete() in views.py on line 311.\n\n\nThe data is sent at redirect() in views.py on line 319.\n\n\nExample 1: The following Python code instructs the user's browser to open a URL parsed from the dest request parameter when a user clicks the link.\n\n\n...\nstrDest = request.field(\"dest\")\nredirect(strDest)\n...\n\n\nIf a victim received an email instructing them to follow a link to \"http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com\", the user would likely click on the link believing they would be transferred to the trusted site. However, when the victim clicks the link, the code in Example 1 will redirect the browser to \"http://www.wilyhacker.com\".\n\nMany users have been educated to always inspect URLs they receive in emails to make sure the link specifies a trusted site they know. However, if the attacker Hex encoded the destination url as follows:\n\"http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D\"\n\nthen even a savvy end-user may be fooled into following the link.\n\nUnvalidated user input should not be allowed to control the destination URL in a redirect. Instead, use a level of indirection: create a list of legitimate URLs that users are allowed to specify and only allow users to select from the list. With this approach, input provided by users is never used directly to specify a URL for redirects.\n\nIn some situations this approach is impractical because the set of legitimate URLs is too large or too hard to keep track of. In such cases, use a similar approach to restrict the domains that users can be redirected to, which can at least prevent attackers from sending users to malicious external sites.\n\nFor more information, see https://ams.fortify.com//redirect/Issues/40723f84-6ff9-4d64-9d33-ab3cecac7fdb"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "146172287",
          "shortDescription" : {
            "text" : "Open Redirect"
          },
          "fullDescription" : {
            "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 573. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
          },
          "help" : {
            "text" : "Redirects allow web applications to direct users to different pages within the same application or to external sites. Applications utilize redirects to aid in site navigation and, in some cases, to track how users exit the site. Open redirect vulnerabilities occur when a web application redirects clients to any arbitrary URL that can be controlled by an attacker.\n\nAttackers might utilize open redirects to trick users into visiting a URL to a trusted site, but then redirecting them to a malicious site. By encoding the URL, an attacker can make it difficult for end-users to notice the malicious destination of the redirect, even when it is passed as a URL parameter to the trusted site. Open redirects are often abused as part of phishing scams to harvest sensitive end-user data.\n\n\nIn this case, the URL the client will be redirected to is accepted at note_edit() in views.py on line 554.\n\n\nThe data is sent at redirect() in views.py on line 573.\n\n\nExample 1: The following Python code instructs the user's browser to open a URL parsed from the dest request parameter when a user clicks the link.\n\n\n...\nstrDest = request.field(\"dest\")\nredirect(strDest)\n...\n\n\nIf a victim received an email instructing them to follow a link to \"http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com\", the user would likely click on the link believing they would be transferred to the trusted site. However, when the victim clicks the link, the code in Example 1 will redirect the browser to \"http://www.wilyhacker.com\".\n\nMany users have been educated to always inspect URLs they receive in emails to make sure the link specifies a trusted site they know. However, if the attacker Hex encoded the destination url as follows:\n\"http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D\"\n\nthen even a savvy end-user may be fooled into following the link.\n\nUnvalidated user input should not be allowed to control the destination URL in a redirect. Instead, use a level of indirection: create a list of legitimate URLs that users are allowed to specify and only allow users to select from the list. With this approach, input provided by users is never used directly to specify a URL for redirects.\n\nIn some situations this approach is impractical because the set of legitimate URLs is too large or too hard to keep track of. In such cases, use a similar approach to restrict the domains that users can be redirected to, which can at least prevent attackers from sending users to malicious external sites.\n\nFor more information, see https://ams.fortify.com//redirect/Issues/19b92729-189c-4a47-9790-54c01e141aa8"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "146172288",
          "shortDescription" : {
            "text" : "Open Redirect"
          },
          "fullDescription" : {
            "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 306. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
          },
          "help" : {
            "text" : "Redirects allow web applications to direct users to different pages within the same application or to external sites. Applications utilize redirects to aid in site navigation and, in some cases, to track how users exit the site. Open redirect vulnerabilities occur when a web application redirects clients to any arbitrary URL that can be controlled by an attacker.\n\nAttackers might utilize open redirects to trick users into visiting a URL to a trusted site, but then redirecting them to a malicious site. By encoding the URL, an attacker can make it difficult for end-users to notice the malicious destination of the redirect, even when it is passed as a URL parameter to the trusted site. Open redirects are often abused as part of phishing scams to harvest sensitive end-user data.\n\n\nIn this case, the URL the client will be redirected to is accepted at task_delete() in views.py on line 299.\n\n\nThe data is sent at redirect() in views.py on line 306.\n\n\nExample 1: The following Python code instructs the user's browser to open a URL parsed from the dest request parameter when a user clicks the link.\n\n\n...\nstrDest = request.field(\"dest\")\nredirect(strDest)\n...\n\n\nIf a victim received an email instructing them to follow a link to \"http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com\", the user would likely click on the link believing they would be transferred to the trusted site. However, when the victim clicks the link, the code in Example 1 will redirect the browser to \"http://www.wilyhacker.com\".\n\nMany users have been educated to always inspect URLs they receive in emails to make sure the link specifies a trusted site they know. However, if the attacker Hex encoded the destination url as follows:\n\"http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D\"\n\nthen even a savvy end-user may be fooled into following the link.\n\nUnvalidated user input should not be allowed to control the destination URL in a redirect. Instead, use a level of indirection: create a list of legitimate URLs that users are allowed to specify and only allow users to select from the list. With this approach, input provided by users is never used directly to specify a URL for redirects.\n\nIn some situations this approach is impractical because the set of legitimate URLs is too large or too hard to keep track of. In such cases, use a similar approach to restrict the domains that users can be redirected to, which can at least prevent attackers from sending users to malicious external sites.\n\nFor more information, see https://ams.fortify.com//redirect/Issues/2089f616-8a60-44ba-a8e7-5d0162588d04"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "146172291",
          "shortDescription" : {
            "text" : "Open Redirect"
          },
          "fullDescription" : {
            "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 590. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
          },
          "help" : {
            "text" : "Redirects allow web applications to direct users to different pages within the same application or to external sites. Applications utilize redirects to aid in site navigation and, in some cases, to track how users exit the site. Open redirect vulnerabilities occur when a web application redirects clients to any arbitrary URL that can be controlled by an attacker.\n\nAttackers might utilize open redirects to trick users into visiting a URL to a trusted site, but then redirecting them to a malicious site. By encoding the URL, an attacker can make it difficult for end-users to notice the malicious destination of the redirect, even when it is passed as a URL parameter to the trusted site. Open redirects are often abused as part of phishing scams to harvest sensitive end-user data.\n\n\nIn this case, the URL the client will be redirected to is accepted at note_delete() in views.py on line 581.\n\n\nThe data is sent at redirect() in views.py on line 590.\n\n\nExample 1: The following Python code instructs the user's browser to open a URL parsed from the dest request parameter when a user clicks the link.\n\n\n...\nstrDest = request.field(\"dest\")\nredirect(strDest)\n...\n\n\nIf a victim received an email instructing them to follow a link to \"http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com\", the user would likely click on the link believing they would be transferred to the trusted site. However, when the victim clicks the link, the code in Example 1 will redirect the browser to \"http://www.wilyhacker.com\".\n\nMany users have been educated to always inspect URLs they receive in emails to make sure the link specifies a trusted site they know. However, if the attacker Hex encoded the destination url as follows:\n\"http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D\"\n\nthen even a savvy end-user may be fooled into following the link.\n\nUnvalidated user input should not be allowed to control the destination URL in a redirect. Instead, use a level of indirection: create a list of legitimate URLs that users are allowed to specify and only allow users to select from the list. With this approach, input provided by users is never used directly to specify a URL for redirects.\n\nIn some situations this approach is impractical because the set of legitimate URLs is too large or too hard to keep track of. In such cases, use a similar approach to restrict the domains that users can be redirected to, which can at least prevent attackers from sending users to malicious external sites.\n\nFor more information, see https://ams.fortify.com//redirect/Issues/4c3f706a-5ca6-47da-8f07-8a2b7914b05a"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "146172293",
          "shortDescription" : {
            "text" : "Open Redirect"
          },
          "fullDescription" : {
            "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 545. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
          },
          "help" : {
            "text" : "Redirects allow web applications to direct users to different pages within the same application or to external sites. Applications utilize redirects to aid in site navigation and, in some cases, to track how users exit the site. Open redirect vulnerabilities occur when a web application redirects clients to any arbitrary URL that can be controlled by an attacker.\n\nAttackers might utilize open redirects to trick users into visiting a URL to a trusted site, but then redirecting them to a malicious site. By encoding the URL, an attacker can make it difficult for end-users to notice the malicious destination of the redirect, even when it is passed as a URL parameter to the trusted site. Open redirects are often abused as part of phishing scams to harvest sensitive end-user data.\n\n\nIn this case, the URL the client will be redirected to is accepted at note_create() in views.py on line 530.\n\n\nThe data is sent at redirect() in views.py on line 545.\n\n\nExample 1: The following Python code instructs the user's browser to open a URL parsed from the dest request parameter when a user clicks the link.\n\n\n...\nstrDest = request.field(\"dest\")\nredirect(strDest)\n...\n\n\nIf a victim received an email instructing them to follow a link to \"http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com\", the user would likely click on the link believing they would be transferred to the trusted site. However, when the victim clicks the link, the code in Example 1 will redirect the browser to \"http://www.wilyhacker.com\".\n\nMany users have been educated to always inspect URLs they receive in emails to make sure the link specifies a trusted site they know. However, if the attacker Hex encoded the destination url as follows:\n\"http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D\"\n\nthen even a savvy end-user may be fooled into following the link.\n\nUnvalidated user input should not be allowed to control the destination URL in a redirect. Instead, use a level of indirection: create a list of legitimate URLs that users are allowed to specify and only allow users to select from the list. With this approach, input provided by users is never used directly to specify a URL for redirects.\n\nIn some situations this approach is impractical because the set of legitimate URLs is too large or too hard to keep track of. In such cases, use a similar approach to restrict the domains that users can be redirected to, which can at least prevent attackers from sending users to malicious external sites.\n\nFor more information, see https://ams.fortify.com//redirect/Issues/5ae52625-6026-4032-8eb3-4cd6058b5b64"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "146172294",
          "shortDescription" : {
            "text" : "Open Redirect"
          },
          "fullDescription" : {
            "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 545. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
          },
          "help" : {
            "text" : "Redirects allow web applications to direct users to different pages within the same application or to external sites. Applications utilize redirects to aid in site navigation and, in some cases, to track how users exit the site. Open redirect vulnerabilities occur when a web application redirects clients to any arbitrary URL that can be controlled by an attacker.\n\nAttackers might utilize open redirects to trick users into visiting a URL to a trusted site, but then redirecting them to a malicious site. By encoding the URL, an attacker can make it difficult for end-users to notice the malicious destination of the redirect, even when it is passed as a URL parameter to the trusted site. Open redirects are often abused as part of phishing scams to harvest sensitive end-user data.\n\n\nIn this case, the URL the client will be redirected to is accepted at note_create() in views.py on line 530.\n\n\nThe data is sent at redirect() in views.py on line 545.\n\n\nExample 1: The following Python code instructs the user's browser to open a URL parsed from the dest request parameter when a user clicks the link.\n\n\n...\nstrDest = request.field(\"dest\")\nredirect(strDest)\n...\n\n\nIf a victim received an email instructing them to follow a link to \"http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com\", the user would likely click on the link believing they would be transferred to the trusted site. However, when the victim clicks the link, the code in Example 1 will redirect the browser to \"http://www.wilyhacker.com\".\n\nMany users have been educated to always inspect URLs they receive in emails to make sure the link specifies a trusted site they know. However, if the attacker Hex encoded the destination url as follows:\n\"http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D\"\n\nthen even a savvy end-user may be fooled into following the link.\n\nUnvalidated user input should not be allowed to control the destination URL in a redirect. Instead, use a level of indirection: create a list of legitimate URLs that users are allowed to specify and only allow users to select from the list. With this approach, input provided by users is never used directly to specify a URL for redirects.\n\nIn some situations this approach is impractical because the set of legitimate URLs is too large or too hard to keep track of. In such cases, use a similar approach to restrict the domains that users can be redirected to, which can at least prevent attackers from sending users to malicious external sites.\n\nFor more information, see https://ams.fortify.com//redirect/Issues/4133417b-52a3-4605-a497-3a2074f43f2a"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "146172295",
          "shortDescription" : {
            "text" : "Open Redirect"
          },
          "fullDescription" : {
            "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 264. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
          },
          "help" : {
            "text" : "Redirects allow web applications to direct users to different pages within the same application or to external sites. Applications utilize redirects to aid in site navigation and, in some cases, to track how users exit the site. Open redirect vulnerabilities occur when a web application redirects clients to any arbitrary URL that can be controlled by an attacker.\n\nAttackers might utilize open redirects to trick users into visiting a URL to a trusted site, but then redirecting them to a malicious site. By encoding the URL, an attacker can make it difficult for end-users to notice the malicious destination of the redirect, even when it is passed as a URL parameter to the trusted site. Open redirects are often abused as part of phishing scams to harvest sensitive end-user data.\n\n\nIn this case, the URL the client will be redirected to is accepted at task_create() in views.py on line 240.\n\n\nThe data is sent at redirect() in views.py on line 264.\n\n\nExample 1: The following Python code instructs the user's browser to open a URL parsed from the dest request parameter when a user clicks the link.\n\n\n...\nstrDest = request.field(\"dest\")\nredirect(strDest)\n...\n\n\nIf a victim received an email instructing them to follow a link to \"http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com\", the user would likely click on the link believing they would be transferred to the trusted site. However, when the victim clicks the link, the code in Example 1 will redirect the browser to \"http://www.wilyhacker.com\".\n\nMany users have been educated to always inspect URLs they receive in emails to make sure the link specifies a trusted site they know. However, if the attacker Hex encoded the destination url as follows:\n\"http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D\"\n\nthen even a savvy end-user may be fooled into following the link.\n\nUnvalidated user input should not be allowed to control the destination URL in a redirect. Instead, use a level of indirection: create a list of legitimate URLs that users are allowed to specify and only allow users to select from the list. With this approach, input provided by users is never used directly to specify a URL for redirects.\n\nIn some situations this approach is impractical because the set of legitimate URLs is too large or too hard to keep track of. In such cases, use a similar approach to restrict the domains that users can be redirected to, which can at least prevent attackers from sending users to malicious external sites.\n\nFor more information, see https://ams.fortify.com//redirect/Issues/5b142752-6d69-46a3-a0b1-4c5d37bfd4be"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "146172296",
          "shortDescription" : {
            "text" : "Open Redirect"
          },
          "fullDescription" : {
            "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 590. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
          },
          "help" : {
            "text" : "Redirects allow web applications to direct users to different pages within the same application or to external sites. Applications utilize redirects to aid in site navigation and, in some cases, to track how users exit the site. Open redirect vulnerabilities occur when a web application redirects clients to any arbitrary URL that can be controlled by an attacker.\n\nAttackers might utilize open redirects to trick users into visiting a URL to a trusted site, but then redirecting them to a malicious site. By encoding the URL, an attacker can make it difficult for end-users to notice the malicious destination of the redirect, even when it is passed as a URL parameter to the trusted site. Open redirects are often abused as part of phishing scams to harvest sensitive end-user data.\n\n\nIn this case, the URL the client will be redirected to is accepted at note_delete() in views.py on line 581.\n\n\nThe data is sent at redirect() in views.py on line 590.\n\n\nExample 1: The following Python code instructs the user's browser to open a URL parsed from the dest request parameter when a user clicks the link.\n\n\n...\nstrDest = request.field(\"dest\")\nredirect(strDest)\n...\n\n\nIf a victim received an email instructing them to follow a link to \"http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com\", the user would likely click on the link believing they would be transferred to the trusted site. However, when the victim clicks the link, the code in Example 1 will redirect the browser to \"http://www.wilyhacker.com\".\n\nMany users have been educated to always inspect URLs they receive in emails to make sure the link specifies a trusted site they know. However, if the attacker Hex encoded the destination url as follows:\n\"http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D\"\n\nthen even a savvy end-user may be fooled into following the link.\n\nUnvalidated user input should not be allowed to control the destination URL in a redirect. Instead, use a level of indirection: create a list of legitimate URLs that users are allowed to specify and only allow users to select from the list. With this approach, input provided by users is never used directly to specify a URL for redirects.\n\nIn some situations this approach is impractical because the set of legitimate URLs is too large or too hard to keep track of. In such cases, use a similar approach to restrict the domains that users can be redirected to, which can at least prevent attackers from sending users to malicious external sites.\n\nFor more information, see https://ams.fortify.com//redirect/Issues/74a729d7-8bf2-4093-a5fb-4b4d51314fd7"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "146172297",
          "shortDescription" : {
            "text" : "Open Redirect"
          },
          "fullDescription" : {
            "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 573. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
          },
          "help" : {
            "text" : "Redirects allow web applications to direct users to different pages within the same application or to external sites. Applications utilize redirects to aid in site navigation and, in some cases, to track how users exit the site. Open redirect vulnerabilities occur when a web application redirects clients to any arbitrary URL that can be controlled by an attacker.\n\nAttackers might utilize open redirects to trick users into visiting a URL to a trusted site, but then redirecting them to a malicious site. By encoding the URL, an attacker can make it difficult for end-users to notice the malicious destination of the redirect, even when it is passed as a URL parameter to the trusted site. Open redirects are often abused as part of phishing scams to harvest sensitive end-user data.\n\n\nIn this case, the URL the client will be redirected to is accepted at note_edit() in views.py on line 554.\n\n\nThe data is sent at redirect() in views.py on line 573.\n\n\nExample 1: The following Python code instructs the user's browser to open a URL parsed from the dest request parameter when a user clicks the link.\n\n\n...\nstrDest = request.field(\"dest\")\nredirect(strDest)\n...\n\n\nIf a victim received an email instructing them to follow a link to \"http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com\", the user would likely click on the link believing they would be transferred to the trusted site. However, when the victim clicks the link, the code in Example 1 will redirect the browser to \"http://www.wilyhacker.com\".\n\nMany users have been educated to always inspect URLs they receive in emails to make sure the link specifies a trusted site they know. However, if the attacker Hex encoded the destination url as follows:\n\"http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D\"\n\nthen even a savvy end-user may be fooled into following the link.\n\nUnvalidated user input should not be allowed to control the destination URL in a redirect. Instead, use a level of indirection: create a list of legitimate URLs that users are allowed to specify and only allow users to select from the list. With this approach, input provided by users is never used directly to specify a URL for redirects.\n\nIn some situations this approach is impractical because the set of legitimate URLs is too large or too hard to keep track of. In such cases, use a similar approach to restrict the domains that users can be redirected to, which can at least prevent attackers from sending users to malicious external sites.\n\nFor more information, see https://ams.fortify.com//redirect/Issues/245ea2d2-a27f-492d-839b-c0778fe318fd"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "146172298",
          "shortDescription" : {
            "text" : "Open Redirect"
          },
          "fullDescription" : {
            "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 291. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
          },
          "help" : {
            "text" : "Redirects allow web applications to direct users to different pages within the same application or to external sites. Applications utilize redirects to aid in site navigation and, in some cases, to track how users exit the site. Open redirect vulnerabilities occur when a web application redirects clients to any arbitrary URL that can be controlled by an attacker.\n\nAttackers might utilize open redirects to trick users into visiting a URL to a trusted site, but then redirecting them to a malicious site. By encoding the URL, an attacker can make it difficult for end-users to notice the malicious destination of the redirect, even when it is passed as a URL parameter to the trusted site. Open redirects are often abused as part of phishing scams to harvest sensitive end-user data.\n\n\nIn this case, the URL the client will be redirected to is accepted at task_edit() in views.py on line 273.\n\n\nThe data is sent at redirect() in views.py on line 291.\n\n\nExample 1: The following Python code instructs the user's browser to open a URL parsed from the dest request parameter when a user clicks the link.\n\n\n...\nstrDest = request.field(\"dest\")\nredirect(strDest)\n...\n\n\nIf a victim received an email instructing them to follow a link to \"http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com\", the user would likely click on the link believing they would be transferred to the trusted site. However, when the victim clicks the link, the code in Example 1 will redirect the browser to \"http://www.wilyhacker.com\".\n\nMany users have been educated to always inspect URLs they receive in emails to make sure the link specifies a trusted site they know. However, if the attacker Hex encoded the destination url as follows:\n\"http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D\"\n\nthen even a savvy end-user may be fooled into following the link.\n\nUnvalidated user input should not be allowed to control the destination URL in a redirect. Instead, use a level of indirection: create a list of legitimate URLs that users are allowed to specify and only allow users to select from the list. With this approach, input provided by users is never used directly to specify a URL for redirects.\n\nIn some situations this approach is impractical because the set of legitimate URLs is too large or too hard to keep track of. In such cases, use a similar approach to restrict the domains that users can be redirected to, which can at least prevent attackers from sending users to malicious external sites.\n\nFor more information, see https://ams.fortify.com//redirect/Issues/8cad2c9a-5487-4fcb-8601-de455d2f3740"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "146172299",
          "shortDescription" : {
            "text" : "Open Redirect"
          },
          "fullDescription" : {
            "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 291. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
          },
          "help" : {
            "text" : "Redirects allow web applications to direct users to different pages within the same application or to external sites. Applications utilize redirects to aid in site navigation and, in some cases, to track how users exit the site. Open redirect vulnerabilities occur when a web application redirects clients to any arbitrary URL that can be controlled by an attacker.\n\nAttackers might utilize open redirects to trick users into visiting a URL to a trusted site, but then redirecting them to a malicious site. By encoding the URL, an attacker can make it difficult for end-users to notice the malicious destination of the redirect, even when it is passed as a URL parameter to the trusted site. Open redirects are often abused as part of phishing scams to harvest sensitive end-user data.\n\n\nIn this case, the URL the client will be redirected to is accepted at task_edit() in views.py on line 273.\n\n\nThe data is sent at redirect() in views.py on line 291.\n\n\nExample 1: The following Python code instructs the user's browser to open a URL parsed from the dest request parameter when a user clicks the link.\n\n\n...\nstrDest = request.field(\"dest\")\nredirect(strDest)\n...\n\n\nIf a victim received an email instructing them to follow a link to \"http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com\", the user would likely click on the link believing they would be transferred to the trusted site. However, when the victim clicks the link, the code in Example 1 will redirect the browser to \"http://www.wilyhacker.com\".\n\nMany users have been educated to always inspect URLs they receive in emails to make sure the link specifies a trusted site they know. However, if the attacker Hex encoded the destination url as follows:\n\"http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D\"\n\nthen even a savvy end-user may be fooled into following the link.\n\nUnvalidated user input should not be allowed to control the destination URL in a redirect. Instead, use a level of indirection: create a list of legitimate URLs that users are allowed to specify and only allow users to select from the list. With this approach, input provided by users is never used directly to specify a URL for redirects.\n\nIn some situations this approach is impractical because the set of legitimate URLs is too large or too hard to keep track of. In such cases, use a similar approach to restrict the domains that users can be redirected to, which can at least prevent attackers from sending users to malicious external sites.\n\nFor more information, see https://ams.fortify.com//redirect/Issues/0b5139bc-9fdb-4320-b0e4-0cd38d63e0f0"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "146172300",
          "shortDescription" : {
            "text" : "Open Redirect"
          },
          "fullDescription" : {
            "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 194. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
          },
          "help" : {
            "text" : "Redirects allow web applications to direct users to different pages within the same application or to external sites. Applications utilize redirects to aid in site navigation and, in some cases, to track how users exit the site. Open redirect vulnerabilities occur when a web application redirects clients to any arbitrary URL that can be controlled by an attacker.\n\nAttackers might utilize open redirects to trick users into visiting a URL to a trusted site, but then redirecting them to a malicious site. By encoding the URL, an attacker can make it difficult for end-users to notice the malicious destination of the redirect, even when it is passed as a URL parameter to the trusted site. Open redirects are often abused as part of phishing scams to harvest sensitive end-user data.\n\n\nIn this case, the URL the client will be redirected to is accepted at upload() in views.py on line 170.\n\n\nThe data is sent at redirect() in views.py on line 194.\n\n\nExample 1: The following Python code instructs the user's browser to open a URL parsed from the dest request parameter when a user clicks the link.\n\n\n...\nstrDest = request.field(\"dest\")\nredirect(strDest)\n...\n\n\nIf a victim received an email instructing them to follow a link to \"http://trusted.example.com/ecommerce/redirect.asp?dest=www.wilyhacker.com\", the user would likely click on the link believing they would be transferred to the trusted site. However, when the victim clicks the link, the code in Example 1 will redirect the browser to \"http://www.wilyhacker.com\".\n\nMany users have been educated to always inspect URLs they receive in emails to make sure the link specifies a trusted site they know. However, if the attacker Hex encoded the destination url as follows:\n\"http://trusted.example.com/ecommerce/redirect.asp?dest=%77%69%6C%79%68%61%63%6B%65%72%2E%63%6F%6D\"\n\nthen even a savvy end-user may be fooled into following the link.\n\nUnvalidated user input should not be allowed to control the destination URL in a redirect. Instead, use a level of indirection: create a list of legitimate URLs that users are allowed to specify and only allow users to select from the list. With this approach, input provided by users is never used directly to specify a URL for redirects.\n\nIn some situations this approach is impractical because the set of legitimate URLs is too large or too hard to keep track of. In such cases, use a similar approach to restrict the domains that users can be redirected to, which can at least prevent attackers from sending users to malicious external sites.\n\nFor more information, see https://ams.fortify.com//redirect/Issues/d9e3f673-d6b5-401d-8696-448d4d4a2bf6"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "146172292",
          "shortDescription" : {
            "text" : "Password Management: Hardcoded Password"
          },
          "fullDescription" : {
            "text" : "Hardcoded passwords could compromise system security in a way that cannot be easily remedied."
          },
          "help" : {
            "text" : "It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. After the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system must choose between security and availability.\n\nIn this case, the password was hardcoded in settings.py on line 101.\n\n\nExample: The following code hardcodes a password:\n\n\npassword = \"tiger\"\n...\nresponse.writeln(\"Password:\" + password)\n\n\nThis code will run successfully, but anyone who has access to it will have access to the password. After the program ships, there is likely no way to change a password of \"tiger\" unless the program is patched. An employee with access to this information can use it to break into the system. Even worse, if attackers have access to the binary for the application they can use one of many publicly available decompilers to access the disassembled code, which will contain the values of the passwords used.\n\nPasswords should never be hardcoded and should generally be obfuscated and managed in an external source. Storing passwords in plain text anywhere on the system allows anyone with sufficient permissions to read and potentially misuse the password.\n\nFor more information, see https://ams.fortify.com//redirect/Issues/c15a29d4-55e8-4a9f-b38c-1c9ebbab9fe7"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "146172301",
          "shortDescription" : {
            "text" : "SQL Injection"
          },
          "fullDescription" : {
            "text" : "Line 184 of views.py invokes a SQL query built with input that comes from an untrusted source. This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.Constructing a dynamic SQL statement with input that comes from an untrusted source might allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands. "
          },
          "help" : {
            "text" : "SQL injection errors occur when:\n\n1. Data enters a program from an untrusted source.\n\n\nIn this case, the data enters at upload() in views.py on line 170.\n\n\n2. The data is used to dynamically construct a SQL query.\n\n\nIn this case, the data is passed to execute() in views.py on line 184.\n\n\nExample 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user.\n\n\n...\nuserName = req.field('userName')\nitemName = req.field('itemName')\nquery = \"SELECT * FROM items WHERE owner = ' \" + userName +\" ' AND itemname = ' \" + itemName +\"';\"\ncursor.execute(query)\nresult = cursor.fetchall()\n...\n\n\nThe query intends to execute the following code:\n\n\nSELECT * FROM items\nWHERE owner = &lt;userName&gt;\nAND itemname = &lt;itemName&gt;;\n\n\nHowever, because the query is constructed dynamically by concatenating a constant query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string \"name' OR 'a'='a\" for itemName, then the query becomes the following:\n\n\nSELECT * FROM items\nWHERE owner = 'wiley'\nAND itemname = 'name' OR 'a'='a';\n\n\nThe addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:\n\n\nSELECT * FROM items;\n\n\nThis simplification of the query allows the attacker to bypass the requirement that the query must only return items owned by the authenticated user. The query now returns all entries stored in the items table, regardless of their specified owner.\n\nExample 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string \"name'; DELETE FROM items; --\" for itemName, then the query becomes the following two queries:\n\n\nSELECT * FROM items\nWHERE owner = 'wiley'\nAND itemname = 'name';\n\nDELETE FROM items;\n\n--'\n\n\nMany database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.\n\nNotice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string \"name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a\", the following three valid statements will be created:\n\n\nSELECT * FROM items\nWHERE owner = 'wiley'\nAND itemname = 'name';\n\nDELETE FROM items;\n\nSELECT * FROM items WHERE 'a'='a';\n\n\nOne traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from an allow list of safe values or identify and escape a list of potentially malicious values (deny list). Checking an allow list can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, implementing a deny list is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers may:\n\n- Target fields that are not quoted\n- Find ways to bypass the need for certain escaped metacharacters\n- Use stored procedures to hide the injected metacharacters\n\nManually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks.\n\nAnother solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks.\n\nThe root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.\n\nMore complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values.\n\nFor more information, see https://ams.fortify.com//redirect/Issues/fa9e9a46-60c2-4bc8-8215-7a1d615048c1"
          },
          "properties" : {
            "tags" : [ "Critical" ],
            "precision" : "high"
          }
        }, {
          "id" : "146172280",
          "shortDescription" : {
            "text" : "System Information Leak: External"
          },
          "fullDescription" : {
            "text" : "Revealing system data or debugging information helps an adversary learn about the system and form a plan of attack."
          },
          "help" : {
            "text" : "An external information leak occurs when system data or debugging information leaves the program to a remote machine via a socket or network connection.\n\nExample 1: The following code prints all the system environment variables as part of the HTTP response:\n\n\n...\nimport cgi\ncgi.print_environ()\n...\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. For example, with scripting mechanisms it is trivial to redirect output information from \"Standard error\" or \"Standard output\" into a file or another program. Alternatively, the system that the program runs on could have a remote logging mechanism such as a \"syslog\" server that sends the logs to a remote device. During development, you have no way of knowing where this information might end up being displayed.\n\nIn some cases, the error message provides the attacker with the precise type of attack to which the system is vulnerable. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In Example 1, the leaked information could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Debug traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\nFor more information, see https://ams.fortify.com//redirect/Issues/f9af6063-c783-47eb-8e63-da5fa4c41b62"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        }, {
          "id" : "146172289",
          "shortDescription" : {
            "text" : "System Information Leak: External"
          },
          "fullDescription" : {
            "text" : "Revealing system data or debugging information helps an adversary learn about the system and form a plan of attack."
          },
          "help" : {
            "text" : "An external information leak occurs when system data or debugging information leaves the program to a remote machine via a socket or network connection.\n\nExample 1: The following code prints all the system environment variables as part of the HTTP response:\n\n\n...\nimport cgi\ncgi.print_environ()\n...\n\n\nDepending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. For example, with scripting mechanisms it is trivial to redirect output information from \"Standard error\" or \"Standard output\" into a file or another program. Alternatively, the system that the program runs on could have a remote logging mechanism such as a \"syslog\" server that sends the logs to a remote device. During development, you have no way of knowing where this information might end up being displayed.\n\nIn some cases, the error message provides the attacker with the precise type of attack to which the system is vulnerable. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In Example 1, the leaked information could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.\n\nWrite error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Debug traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).\n\nEven brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an \"Access Denied\" message can reveal that a file or user exists on the system.\n\nFor more information, see https://ams.fortify.com//redirect/Issues/a2d6c046-291f-421a-8f8b-77d53ad6c394"
          },
          "properties" : {
            "tags" : [ "High" ],
            "precision" : "low"
          }
        } ]
      }
    },
    "results" : [ {
      "ruleId" : "146172283",
      "message" : {
        "text" : "The program does not explicitly set the CSRF_COOKIE_SECURE property to True or sets it to False in settings.py on line 16. The program does not explicitly set the CSRF_COOKIE_SECURE property to True or set it to False."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "AD0618D59C6C7C72456A985EADF9F5C9"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/settings.py"
          },
          "region" : {
            "startLine" : 16,
            "endLine" : 16,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "settings.py:16 - Block"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/settings.py"
                },
                "region" : {
                  "startLine" : 16
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "settings.py:44 - AssignmentStatement"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/settings.py"
                },
                "region" : {
                  "startLine" : 44
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "146172290",
      "message" : {
        "text" : "The program does not explicitly set the SESSION_COOKIE_SECURE property to True or set it to False in settings.py on line 16. The program does not explicitly set the SESSION_COOKIE_SECURE property to True or set it to False."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "E93BFD5918DA8CBAFF95B9167B1C4C3C"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/settings.py"
          },
          "region" : {
            "startLine" : 16,
            "endLine" : 16,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "settings.py:16 - Block"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/settings.py"
                },
                "region" : {
                  "startLine" : 16
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "settings.py:44 - AssignmentStatement"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/settings.py"
                },
                "region" : {
                  "startLine" : 44
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "146172282",
      "message" : {
        "text" : "Cookie-based sessions are not invalidated when a user logs out. If an attacker were to find, steal, or intercept a user's cookie they could impersonate the user even if that user had logged out."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "6EC45FEF0E9B4E6BCD8ED2AD2CFCE75F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/settings.py"
          },
          "region" : {
            "startLine" : 104,
            "endLine" : 104,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "settings.py:104 - AssignmentStatement"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/settings.py"
                },
                "region" : {
                  "startLine" : 104
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "settings.py:104 - VariableAccess: SESSION_ENGINE"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/settings.py"
                },
                "region" : {
                  "startLine" : 104
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "146172279",
      "message" : {
        "text" : "Pickle-serialized sessions can lead to remote code execution if attackers can control session data."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "486506D8686D62CB58263F42EF9EA6BD"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/settings.py"
          },
          "region" : {
            "startLine" : 109,
            "endLine" : 109,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "settings.py:109 - AssignmentStatement"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/settings.py"
                },
                "region" : {
                  "startLine" : 109
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "settings.py:109 - VariableAccess: SESSION_SERIALIZER"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/settings.py"
                },
                "region" : {
                  "startLine" : 109
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "146172285",
      "message" : {
        "text" : "The application is not configured to send HTTP redirects over SSL/TLS."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "BF17023672C75DF484A9A56A1549D745"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/settings.py"
          },
          "region" : {
            "startLine" : 16,
            "endLine" : 16,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "settings.py:16 - Block"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/settings.py"
                },
                "region" : {
                  "startLine" : 16
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "settings.py:44 - AssignmentStatement"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/settings.py"
                },
                "region" : {
                  "startLine" : 44
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "146172278",
      "message" : {
        "text" : "The application does not set HTTP Strict Transport Security (HSTS) headers, allowing attackers to replace SSL/TLS connections with plain HTTP ones and steal sensitive information by performing HTTPS stripping attacks."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "2AF6A8C7A8DD3EEACDD4C828BFF3A6F6"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/settings.py"
          },
          "region" : {
            "startLine" : 16,
            "endLine" : 16,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "settings.py:16 - Block"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/settings.py"
                },
                "region" : {
                  "startLine" : 16
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "settings.py:44 - AssignmentStatement"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/settings.py"
                },
                "region" : {
                  "startLine" : 44
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "146172281",
      "message" : {
        "text" : "Hardcoded encryption keys could compromise system security in a way that cannot be easily remedied."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "19DDDB5735410A64F88084A1B4F58F1E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/settings.py"
          },
          "region" : {
            "startLine" : 24,
            "endLine" : 24,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "settings.py:24 - AssignmentStatement"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/settings.py"
                },
                "region" : {
                  "startLine" : 24
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "settings.py:24 - VariableAccess: SECRET_KEY"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/settings.py"
                },
                "region" : {
                  "startLine" : 24
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "146172284",
      "message" : {
        "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 368. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "BF028F51ABAA150FFA78BFCA5E9C3631"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/views.py"
          },
          "region" : {
            "startLine" : 368,
            "endLine" : 368,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "views.py:350 - project_edit(1)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 350
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "views.py:368 - redirect(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 368
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "146172286",
      "message" : {
        "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 319. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "2647EDB86A99599FFBBAD1CDD5ABE2DF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/views.py"
          },
          "region" : {
            "startLine" : 319,
            "endLine" : 319,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "views.py:311 - task_complete(1)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 311
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "views.py:319 - redirect(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 319
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "146172287",
      "message" : {
        "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 573. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "C4C5D83A1F4FDD0C795B08BEA1796DFF"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/views.py"
          },
          "region" : {
            "startLine" : 573,
            "endLine" : 573,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "views.py:554 - note_edit(2)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 554
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "views.py:573 - redirect(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 573
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "146172288",
      "message" : {
        "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 306. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "646CA549631192C553D1B083992AFCF7"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/views.py"
          },
          "region" : {
            "startLine" : 306,
            "endLine" : 306,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "views.py:299 - task_delete(1)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 299
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "views.py:306 - redirect(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 306
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "146172291",
      "message" : {
        "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 590. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "EAD606D6F6A5A2C5388D9336C3E9810F"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/views.py"
          },
          "region" : {
            "startLine" : 590,
            "endLine" : 590,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "views.py:581 - note_delete(2)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 581
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "views.py:590 - redirect(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 590
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "146172293",
      "message" : {
        "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 545. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "F56D504674CA50F4DB0EB66228C6E430"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/views.py"
          },
          "region" : {
            "startLine" : 545,
            "endLine" : 545,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "views.py:530 - note_create(1)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 530
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "views.py:545 - redirect(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 545
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "146172294",
      "message" : {
        "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 545. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "634EE60B51A84DC9AB23207A514D7714"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/views.py"
          },
          "region" : {
            "startLine" : 545,
            "endLine" : 545,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "views.py:530 - note_create(2)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 530
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "views.py:545 - redirect(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 545
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "146172295",
      "message" : {
        "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 264. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "1C9931ACF00CCC1B126BD888899C79BB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/views.py"
          },
          "region" : {
            "startLine" : 264,
            "endLine" : 264,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "views.py:240 - task_create(1)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 240
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "views.py:264 - redirect(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 264
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "146172296",
      "message" : {
        "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 590. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "8D733E4BB3CA9D2C58BF6556A60F548D"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/views.py"
          },
          "region" : {
            "startLine" : 590,
            "endLine" : 590,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "views.py:581 - note_delete(1)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 581
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "views.py:590 - redirect(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 590
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "146172297",
      "message" : {
        "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 573. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "37DB9A654366AF2A653F1924F6C86386"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/views.py"
          },
          "region" : {
            "startLine" : 573,
            "endLine" : 573,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "views.py:554 - note_edit(1)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 554
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "views.py:573 - redirect(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 573
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "146172298",
      "message" : {
        "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 291. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "69B0F6B34C1BB7EF4E0768695318E591"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/views.py"
          },
          "region" : {
            "startLine" : 291,
            "endLine" : 291,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "views.py:273 - task_edit(1)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 273
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "views.py:291 - redirect(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 291
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "146172299",
      "message" : {
        "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 291. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "B407C69ACDC3588CFB7381AE5A31A012"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/views.py"
          },
          "region" : {
            "startLine" : 291,
            "endLine" : 291,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "views.py:273 - task_edit(2)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 273
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "views.py:291 - redirect(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 291
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "146172300",
      "message" : {
        "text" : "The file views.py passes unvalidated data to an HTTP redirect function on line 194. Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "3927138614DDFCB52A1A25DEAD3ECD9E"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/views.py"
          },
          "region" : {
            "startLine" : 194,
            "endLine" : 194,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "views.py:170 - upload(1)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 170
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "views.py:194 - redirect(0)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 194
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "146172292",
      "message" : {
        "text" : "Hardcoded passwords could compromise system security in a way that cannot be easily remedied."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "EDD785634D088E1C3C135223B4BBFB42"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/settings.py"
          },
          "region" : {
            "startLine" : 101,
            "endLine" : 101,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "settings.py:101 - VariableAccess: PASSWORD_HASHERS"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/settings.py"
                },
                "region" : {
                  "startLine" : 101
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "settings.py:101 - Variable: PASSWORD_HASHERS"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/settings.py"
                },
                "region" : {
                  "startLine" : 101
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "146172301",
      "message" : {
        "text" : "Line 184 of views.py invokes a SQL query built with input that comes from an untrusted source. This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.Constructing a dynamic SQL statement with input that comes from an untrusted source might allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands. "
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "C0DB6BA247FA3A6F2C550A602D828C77"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/views.py"
          },
          "region" : {
            "startLine" : 184,
            "endLine" : 184,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "views.py:170 - upload(1)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 170
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "views.py:184 - execute(1)"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/views.py"
                },
                "region" : {
                  "startLine" : 184
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "146172280",
      "message" : {
        "text" : "Revealing system data or debugging information helps an adversary learn about the system and form a plan of attack."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "2B93C83A4867712F53258F39D02AE0CB"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/settings.py"
          },
          "region" : {
            "startLine" : 29,
            "endLine" : 29,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "settings.py:29 - AssignmentStatement"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/settings.py"
                },
                "region" : {
                  "startLine" : 29
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "settings.py:29 - VariableAccess: TEMPLATE_DEBUG"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/settings.py"
                },
                "region" : {
                  "startLine" : 29
                }
              }
            }
          } ]
        } ]
      } ]
    }, {
      "ruleId" : "146172289",
      "message" : {
        "text" : "Revealing system data or debugging information helps an adversary learn about the system and form a plan of attack."
      },
      "level" : "warning",
      "partialFingerprints" : {
        "issueInstanceId" : "C9A0433C14D2F5E24FF6BCFEBABAE595"
      },
      "locations" : [ {
        "physicalLocation" : {
          "artifactLocation" : {
            "uri" : "taskManager/settings.py"
          },
          "region" : {
            "startLine" : 28,
            "endLine" : 28,
            "startColumn" : 1,
            "endColumn" : 80
          }
        }
      } ],
      "codeFlows" : [ {
        "threadFlows" : [ {
          "locations" : [ {
            "location" : {
              "message" : {
                "text" : "settings.py:28 - AssignmentStatement"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/settings.py"
                },
                "region" : {
                  "startLine" : 28
                }
              }
            }
          }, {
            "location" : {
              "message" : {
                "text" : "settings.py:28 - VariableAccess: DEBUG"
              },
              "physicalLocation" : {
                "artifactLocation" : {
                  "uri" : "taskManager/settings.py"
                },
                "region" : {
                  "startLine" : 28
                }
              }
            }
          } ]
        } ]
      } ]
    } ]
  } ]
}